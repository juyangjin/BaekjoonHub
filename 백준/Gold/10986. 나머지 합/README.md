# [Gold III] 나머지 합 - 10986 

[문제 링크](https://www.acmicpc.net/problem/10986) 

### 성능 요약

메모리: 328416 KB, 시간: 1836 ms

### 분류

수학, 누적 합

### 제출 일자

2024년 6월 21일 12:40:42

### 문제 설명

<p>수 N개 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.</p>

<p>즉, A<sub>i</sub> + ... + A<sub>j</sub> (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.</p>

### 입력 

 <p>첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 10<sup>6</sup>, 2 ≤ M ≤ 10<sup>3</sup>)</p>

<p>둘째 줄에 N개의 수 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (0 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)</p>

### 출력 

 <p>첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.</p>

### 풀이 출처 및 정리 

오늘문제는 정말 쉽지 않았다. 사실 처음엔 예시를 안 보고 풀어보려고 어제 했던대로 BufferedReader과 StringTokenizer을 사용하려고 했다. 근데 오늘은 그렇게 했더니 틀렸다. 계속 컴파일에러가 나서 정답 부분을 보고 고쳐보려 했으나 그것조차 안되었다. 근데 인터넷에 검색해보니 버퍼는 공백도 인식한다는 걸 알게 되었다. 결국 주어진 값 중간에 공백이 있기 때문에 버퍼를 사용하려면 공백에 대한 처리를 해 주어야 한다는 것이었다. 그래서 무난하게, 그리고 책에 나온대로 Scanner를 사용했다.

문제는 저번처럼 구간 합을 구한 뒤에 처리해야 빠른 처리가 가능한 것이었다.
먼저 N값과 M값을 스캔으로 받고 배열 S를 선언하고, 나머지 값이 같을 때를 대비한 배열 C도 선언해주었다. 풀다보니 원본배열은 왜 없지? 하는 생각이 들어서 책을 보니 S[i-1]-A[i] 공식이지만 A[i]가 복잡하지 않으니 스캐너 함수로 그 부분을 대체했다.

그리고 remainder 변수를 선언하여 S[i] 값을 M으로 나눈 값을 담았다.
if문으로 remainder 함수 값이 0일 경우, S[i]에 저장된 구간 합의 값이 M으로 나누었을 때 딱 떨어진다는 의미이기 때문에 answer++ 해주었다.
그리고 C[remainder]은 나머지 값에 따라서 C인덱스 값이 늘어나게 된다.
0일 경우 0번 인덱스가 1 늘어나고, 다른 나머지 값일 경우 그 인덱스의 값이 1씩 늘어나게 된다.

마지막 for 문은 위에서 설명한 C배열에 대한 예외를 합산하는 것이다. M만큼 반복하는데 그 때 C[i]가 1보다 크다면 나머지가 동일한 인덱스가 2개일 경우이므로 answer 값에 i-1번 인덱스와 i번 인덱스를 곱하여 2로 나눈 값을 더해준다. 

그렇게 되면 최종적으로 answer에는 나머지가 0일 때의 값과 나머지가 같은 2개의 인덱스 끼리의 경우까지 값이 전부 더해지고 println으로 출력되게 된다.  

출처 DO it! 알고리즘 코딩테스트 자바 편(김종관 저) 전자책 54-55Page

